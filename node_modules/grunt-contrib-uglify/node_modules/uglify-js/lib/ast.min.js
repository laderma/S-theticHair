"use strict";function DEFNODE(e,n,t,r){arguments.length<4&&(r=AST_Node),n=n?n.split(/\s+/):[];var a=n;r&&r.PROPS&&(n=n.concat(r.PROPS));for(var i="return function AST_"+e+"(props){ if (props) { ",s=n.length;--s>=0;)i+="this."+n[s]+" = props."+n[s]+";";var o=r&&new r;(o&&o.initialize||t&&t.initialize)&&(i+="this.initialize();"),i+="}}";var l=new Function(i)();if(o&&(l.prototype=o,l.BASE=r),r&&r.SUBCLASSES.push(l),l.prototype.CTOR=l,l.PROPS=n||null,l.SELF_PROPS=a,l.SUBCLASSES=[],e&&(l.prototype.TYPE=l.TYPE=e),t)for(s in t)t.hasOwnProperty(s)&&(/^\$/.test(s)?l[s.substr(1)]=t[s]:l.prototype[s]=t[s]);return l.DEFMETHOD=function(e,n){this.prototype[e]=n},l}function walk_body(e,n){e.body instanceof AST_Statement?e.body._walk(n):e.body.forEach(function(e){e._walk(n)})}function TreeWalker(e){this.visit=e,this.stack=[]}var AST_Token=DEFNODE("Token","type value line col pos endline endcol endpos nlb comments_before file",{},null),AST_Node=DEFNODE("Node","start end",{clone:function(){return new this.CTOR(this)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(e){return e._visit(this)},walk:function(e){return this._walk(e)}},null);AST_Node.warn_function=null,AST_Node.warn=function(e,n){AST_Node.warn_function&&AST_Node.warn_function(string_template(e,n))};var AST_Statement=DEFNODE("Statement",null,{$documentation:"Base class of all statements"}),AST_Debugger=DEFNODE("Debugger",null,{$documentation:"Represents a debugger statement"},AST_Statement),AST_Directive=DEFNODE("Directive","value scope quote",{$documentation:'Represents a directive, like "use strict";',$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",scope:"[AST_Scope/S] The scope that this directive affects",quote:"[string] the original quote character"}},AST_Statement),AST_SimpleStatement=DEFNODE("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(e){return e._visit(this,function(){this.body._walk(e)})}},AST_Statement),AST_Block=DEFNODE("Block","body",{$documentation:"A body of statements (usually bracketed)",$propdoc:{body:"[AST_Statement*] an array of statements"},_walk:function(e){return e._visit(this,function(){walk_body(this,e)})}},AST_Statement),AST_BlockStatement=DEFNODE("BlockStatement",null,{$documentation:"A block statement"},AST_Block),AST_EmptyStatement=DEFNODE("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)",_walk:function(e){return e._visit(this)}},AST_Statement),AST_StatementWithBody=DEFNODE("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"},_walk:function(e){return e._visit(this,function(){this.body._walk(e)})}},AST_Statement),AST_LabeledStatement=DEFNODE("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(e){return e._visit(this,function(){this.label._walk(e),this.body._walk(e)})}},AST_StatementWithBody),AST_IterationStatement=DEFNODE("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it."},AST_StatementWithBody),AST_DWLoop=DEFNODE("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"}},AST_IterationStatement),AST_Do=DEFNODE("Do",null,{$documentation:"A `do` statement",_walk:function(e){return e._visit(this,function(){this.body._walk(e),this.condition._walk(e)})}},AST_DWLoop),AST_While=DEFNODE("While",null,{$documentation:"A `while` statement",_walk:function(e){return e._visit(this,function(){this.condition._walk(e),this.body._walk(e)})}},AST_DWLoop),AST_For=DEFNODE("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_walk:function(e){return e._visit(this,function(){this.init&&this.init._walk(e),this.condition&&this.condition._walk(e),this.step&&this.step._walk(e),this.body._walk(e)})}},AST_IterationStatement),AST_ForIn=DEFNODE("ForIn","init name object",{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",name:"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",object:"[AST_Node] the object that we're looping through"},_walk:function(e){return e._visit(this,function(){this.init._walk(e),this.object._walk(e),this.body._walk(e)})}},AST_IterationStatement),AST_With=DEFNODE("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e),this.body._walk(e)})}},AST_StatementWithBody),AST_Scope=DEFNODE("Scope","directives variables functions uses_with uses_eval parent_scope enclosed cname",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{directives:"[string*/S] an array of directives declared in this scope",variables:"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",functions:"[Object/S] like `variables`, but only lists function declarations",uses_with:"[boolean/S] tells whether this scope uses the `with` statement",uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",cname:"[integer/S] current index for mangling variables (used internally by the mangler)"}},AST_Block),AST_Toplevel=DEFNODE("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Object/S] a map of name -> SymbolDef for all undeclared names"},wrap_enclose:function(e){var n=this,t=[],r=[];e.forEach(function(e){var n=e.lastIndexOf(":");t.push(e.substr(0,n)),r.push(e.substr(n+1))});var a="(function("+r.join(",")+"){ '$ORIG'; })("+t.join(",")+")";return a=parse(a),a=a.transform(new TreeTransformer(function(e){return e instanceof AST_Directive&&"$ORIG"==e.value?MAP.splice(n.body):void 0}))},wrap_commonjs:function(e,n){var t=this,r=[];n&&(t.figure_out_scope(),t.walk(new TreeWalker(function(e){e instanceof AST_SymbolDeclaration&&e.definition().global&&(find_if(function(n){return n.name==e.name},r)||r.push(e))})));var a="(function(exports, global){ global['"+e+"'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))";return a=parse(a),a=a.transform(new TreeTransformer(function(e){if(e instanceof AST_SimpleStatement&&(e=e.body,e instanceof AST_String))switch(e.getValue()){case"$ORIG":return MAP.splice(t.body);case"$EXPORTS":var n=[];return r.forEach(function(e){n.push(new AST_SimpleStatement({body:new AST_Assign({left:new AST_Sub({expression:new AST_SymbolRef({name:"exports"}),property:new AST_String({value:e.name})}),operator:"=",right:new AST_SymbolRef(e)})}))}),MAP.splice(n)}}))}},AST_Scope),AST_Lambda=DEFNODE("Lambda","name argnames uses_arguments",{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function",argnames:"[AST_SymbolFunarg*] array of function arguments",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array"},_walk:function(e){return e._visit(this,function(){this.name&&this.name._walk(e),this.argnames.forEach(function(n){n._walk(e)}),walk_body(this,e)})}},AST_Scope),AST_Accessor=DEFNODE("Accessor",null,{$documentation:"A setter/getter function.  The `name` property is always null."},AST_Lambda),AST_Function=DEFNODE("Function",null,{$documentation:"A function expression"},AST_Lambda),AST_Defun=DEFNODE("Defun",null,{$documentation:"A function definition"},AST_Lambda),AST_Jump=DEFNODE("Jump",null,{$documentation:"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"},AST_Statement),AST_Exit=DEFNODE("Exit","value",{$documentation:"Base class for “exits” (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(e){return e._visit(this,this.value&&function(){this.value._walk(e)})}},AST_Jump),AST_Return=DEFNODE("Return",null,{$documentation:"A `return` statement"},AST_Exit),AST_Throw=DEFNODE("Throw",null,{$documentation:"A `throw` statement"},AST_Exit),AST_LoopControl=DEFNODE("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(e){return e._visit(this,this.label&&function(){this.label._walk(e)})}},AST_Jump),AST_Break=DEFNODE("Break",null,{$documentation:"A `break` statement"},AST_LoopControl),AST_Continue=DEFNODE("Continue",null,{$documentation:"A `continue` statement"},AST_LoopControl),AST_If=DEFNODE("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(e){return e._visit(this,function(){this.condition._walk(e),this.body._walk(e),this.alternative&&this.alternative._walk(e)})}},AST_StatementWithBody),AST_Switch=DEFNODE("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` “discriminant”"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e),walk_body(this,e)})}},AST_Block),AST_SwitchBranch=DEFNODE("SwitchBranch",null,{$documentation:"Base class for `switch` branches"},AST_Block),AST_Default=DEFNODE("Default",null,{$documentation:"A `default` switch branch"},AST_SwitchBranch),AST_Case=DEFNODE("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e),walk_body(this,e)})}},AST_SwitchBranch),AST_Try=DEFNODE("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(e){return e._visit(this,function(){walk_body(this,e),this.bcatch&&this.bcatch._walk(e),this.bfinally&&this.bfinally._walk(e)})}},AST_Block),AST_Catch=DEFNODE("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[AST_SymbolCatch] symbol for the exception"},_walk:function(e){return e._visit(this,function(){this.argname._walk(e),walk_body(this,e)})}},AST_Block),AST_Finally=DEFNODE("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},AST_Block),AST_Definitions=DEFNODE("Definitions","definitions",{$documentation:"Base class for `var` or `const` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_walk:function(e){return e._visit(this,function(){this.definitions.forEach(function(n){n._walk(e)})})}},AST_Statement),AST_Var=DEFNODE("Var",null,{$documentation:"A `var` statement"},AST_Definitions),AST_Const=DEFNODE("Const",null,{$documentation:"A `const` statement"},AST_Definitions),AST_VarDef=DEFNODE("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_SymbolVar|AST_SymbolConst] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_walk:function(e){return e._visit(this,function(){this.name._walk(e),this.value&&this.value._walk(e)})}}),AST_Call=DEFNODE("Call","expression args",{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function",args:"[AST_Node*] array of arguments"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e),this.args.forEach(function(n){n._walk(e)})})}}),AST_New=DEFNODE("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties"},AST_Call),AST_Seq=DEFNODE("Seq","car cdr",{$documentation:"A sequence expression (two comma-separated expressions)",$propdoc:{car:"[AST_Node] first element in sequence",cdr:"[AST_Node] second element in sequence"},$cons:function(e,n){var t=new AST_Seq(e);return t.car=e,t.cdr=n,t},$from_array:function(e){if(0==e.length)return null;if(1==e.length)return e[0].clone();for(var n=null,t=e.length;--t>=0;)n=AST_Seq.cons(e[t],n);for(var r=n;r;){if(r.cdr&&!r.cdr.cdr){r.cdr=r.cdr.car;break}r=r.cdr}return n},to_array:function(){for(var e=this,n=[];e;){if(n.push(e.car),e.cdr&&!(e.cdr instanceof AST_Seq)){n.push(e.cdr);break}e=e.cdr}return n},add:function(e){for(var n=this;n;){if(!(n.cdr instanceof AST_Seq)){var t=AST_Seq.cons(n.cdr,e);return n.cdr=t}n=n.cdr}},_walk:function(e){return e._visit(this,function(){this.car._walk(e),this.cdr&&this.cdr._walk(e)})}}),AST_PropAccess=DEFNODE("PropAccess","expression property",{$documentation:'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',$propdoc:{expression:"[AST_Node] the “container” expression",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"}}),AST_Dot=DEFNODE("Dot",null,{$documentation:"A dotted property access expression",_walk:function(e){return e._visit(this,function(){this.expression._walk(e)})}},AST_PropAccess),AST_Sub=DEFNODE("Sub",null,{$documentation:'Index-style property access, i.e. `a["foo"]`',_walk:function(e){return e._visit(this,function(){this.expression._walk(e),this.property._walk(e)})}},AST_PropAccess),AST_Unary=DEFNODE("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(e){return e._visit(this,function(){this.expression._walk(e)})}}),AST_UnaryPrefix=DEFNODE("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},AST_Unary),AST_UnaryPostfix=DEFNODE("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},AST_Unary),AST_Binary=DEFNODE("Binary","left operator right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(e){return e._visit(this,function(){this.left._walk(e),this.right._walk(e)})}}),AST_Conditional=DEFNODE("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(e){return e._visit(this,function(){this.condition._walk(e),this.consequent._walk(e),this.alternative._walk(e)})}}),AST_Assign=DEFNODE("Assign",null,{$documentation:"An assignment expression — `a = b + 5`"},AST_Binary),AST_Array=DEFNODE("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(e){return e._visit(this,function(){this.elements.forEach(function(n){n._walk(e)})})}}),AST_Object=DEFNODE("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(e){return e._visit(this,function(){this.properties.forEach(function(n){n._walk(e)})})}}),AST_ObjectProperty=DEFNODE("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string] the property name converted to a string for ObjectKeyVal.  For setters and getters this is an arbitrary AST_Node.",value:"[AST_Node] property value.  For setters and getters this is an AST_Function."},_walk:function(e){return e._visit(this,function(){this.value._walk(e)})}}),AST_ObjectKeyVal=DEFNODE("ObjectKeyVal","quote",{$documentation:"A key: value object property",$propdoc:{quote:"[string] the original quote character"}},AST_ObjectProperty),AST_ObjectSetter=DEFNODE("ObjectSetter",null,{$documentation:"An object setter property"},AST_ObjectProperty),AST_ObjectGetter=DEFNODE("ObjectGetter",null,{$documentation:"An object getter property"},AST_ObjectProperty),AST_Symbol=DEFNODE("Symbol","scope name thedef",{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"}),AST_SymbolAccessor=DEFNODE("SymbolAccessor",null,{$documentation:"The name of a property accessor (setter/getter function)"},AST_Symbol),AST_SymbolDeclaration=DEFNODE("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",$propdoc:{init:"[AST_Node*/S] array of initializers for this declaration."}},AST_Symbol),AST_SymbolVar=DEFNODE("SymbolVar",null,{$documentation:"Symbol defining a variable"},AST_SymbolDeclaration),AST_SymbolConst=DEFNODE("SymbolConst",null,{$documentation:"A constant declaration"},AST_SymbolDeclaration),AST_SymbolFunarg=DEFNODE("SymbolFunarg",null,{$documentation:"Symbol naming a function argument"},AST_SymbolVar),AST_SymbolDefun=DEFNODE("SymbolDefun",null,{$documentation:"Symbol defining a function"},AST_SymbolDeclaration),AST_SymbolLambda=DEFNODE("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},AST_SymbolDeclaration),AST_SymbolCatch=DEFNODE("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},AST_SymbolDeclaration),AST_Label=DEFNODE("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},AST_Symbol),AST_SymbolRef=DEFNODE("SymbolRef",null,{$documentation:"Reference to some symbol (not definition/declaration)"},AST_Symbol),AST_LabelRef=DEFNODE("LabelRef",null,{$documentation:"Reference to a label symbol"},AST_Symbol),AST_This=DEFNODE("This",null,{$documentation:"The `this` symbol"},AST_Symbol),AST_Constant=DEFNODE("Constant",null,{$documentation:"Base class for all constants",getValue:function(){return this.value}}),AST_String=DEFNODE("String","value quote",{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",quote:"[string] the original quote character"}},AST_Constant),AST_Number=DEFNODE("Number","value",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value"}},AST_Constant),AST_RegExp=DEFNODE("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"}},AST_Constant),AST_Atom=DEFNODE("Atom",null,{$documentation:"Base class for atoms"},AST_Constant),AST_Null=DEFNODE("Null",null,{$documentation:"The `null` atom",value:null},AST_Atom),AST_NaN=DEFNODE("NaN",null,{$documentation:"The impossible value",value:NaN},AST_Atom),AST_Undefined=DEFNODE("Undefined",null,{$documentation:"The `undefined` value",value:void 0},AST_Atom),AST_Hole=DEFNODE("Hole",null,{$documentation:"A hole in an array",value:void 0},AST_Atom),AST_Infinity=DEFNODE("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},AST_Atom),AST_Boolean=DEFNODE("Boolean",null,{$documentation:"Base class for booleans"},AST_Atom),AST_False=DEFNODE("False",null,{$documentation:"The `false` atom",value:!1},AST_Boolean),AST_True=DEFNODE("True",null,{$documentation:"The `true` atom",value:!0},AST_Boolean);TreeWalker.prototype={_visit:function(e,n){this.stack.push(e);var t=this.visit(e,n?function(){n.call(e)}:noop);return!t&&n&&n.call(e),this.stack.pop(),t},parent:function(e){return this.stack[this.stack.length-2-(e||0)]},push:function(e){this.stack.push(e)},pop:function(){return this.stack.pop()},self:function(){return this.stack[this.stack.length-1]},find_parent:function(e){for(var n=this.stack,t=n.length;--t>=0;){var r=n[t];if(r instanceof e)return r}},has_directive:function(e){return this.find_parent(AST_Scope).has_directive(e)},in_boolean_context:function(){for(var e=this.stack,n=e.length,t=e[--n];n>0;){var r=e[--n];if(r instanceof AST_If&&r.condition===t||r instanceof AST_Conditional&&r.condition===t||r instanceof AST_DWLoop&&r.condition===t||r instanceof AST_For&&r.condition===t||r instanceof AST_UnaryPrefix&&"!"==r.operator&&r.expression===t)return!0;if(!(r instanceof AST_Binary)||"&&"!=r.operator&&"||"!=r.operator)return!1;t=r}},loopcontrol_target:function(e){var n=this.stack;if(e)for(var t=n.length;--t>=0;){var r=n[t];if(r instanceof AST_LabeledStatement&&r.label.name==e.name)return r.body}else for(var t=n.length;--t>=0;){var r=n[t];if(r instanceof AST_Switch||r instanceof AST_IterationStatement)return r}}};