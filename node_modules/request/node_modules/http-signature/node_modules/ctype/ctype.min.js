function ctReadUint8(e,n,t){var r=mod_ctio.ruint8(n,e,t);return{value:r,size:1}}function ctReadUint16(e,n,t){var r=mod_ctio.ruint16(n,e,t);return{value:r,size:2}}function ctReadUint32(e,n,t){var r=mod_ctio.ruint32(n,e,t);return{value:r,size:4}}function ctReadUint64(e,n,t){var r=mod_ctio.ruint64(n,e,t);return{value:r,size:8}}function ctReadSint8(e,n,t){var r=mod_ctio.rsint8(n,e,t);return{value:r,size:1}}function ctReadSint16(e,n,t){var r=mod_ctio.rsint16(n,e,t);return{value:r,size:2}}function ctReadSint32(e,n,t){var r=mod_ctio.rsint32(n,e,t);return{value:r,size:4}}function ctReadSint64(e,n,t){var r=mod_ctio.rsint64(n,e,t);return{value:r,size:8}}function ctReadFloat(e,n,t){var r=mod_ctio.rfloat(n,e,t);return{value:r,size:4}}function ctReadDouble(e,n,t){var r=mod_ctio.rdouble(n,e,t);return{value:r,size:8}}function ctReadChar(e,n,t){var r=new Buffer(1);return r[0]=mod_ctio.ruint8(n,e,t),{value:r,size:1}}function ctReadCharArray(e,n,t,r){var i,a=new Buffer(e);for(i=0;e>i;i++)a[i]=mod_ctio.ruint8(t,n,r+i);return{value:a,size:e}}function ctWriteUint8(e,n,t,r){return mod_ctio.wuint8(e,n,t,r),1}function ctWriteUint16(e,n,t,r){return mod_ctio.wuint16(e,n,t,r),2}function ctWriteUint32(e,n,t,r){return mod_ctio.wuint32(e,n,t,r),4}function ctWriteUint64(e,n,t,r){return mod_ctio.wuint64(e,n,t,r),8}function ctWriteSint8(e,n,t,r){return mod_ctio.wsint8(e,n,t,r),1}function ctWriteSint16(e,n,t,r){return mod_ctio.wsint16(e,n,t,r),2}function ctWriteSint32(e,n,t,r){return mod_ctio.wsint32(e,n,t,r),4}function ctWriteSint64(e,n,t,r){return mod_ctio.wsint64(e,n,t,r),8}function ctWriteFloat(e,n,t,r){return mod_ctio.wfloat(e,n,t,r),4}function ctWriteDouble(e,n,t,r){return mod_ctio.wdouble(e,n,t,r),8}function ctWriteChar(e,n,t,r){if(!(e instanceof Buffer))throw new Error("Input must be a buffer");return mod_ctio.ruint8(e[0],n,t,r),1}function ctWriteCharArray(e,n,t,r,i){var a;if(!(e instanceof Buffer))throw new Error("Input must be a buffer");if(e.length>n)throw new Error("value length greater than array length");for(a=0;a<e.length&&n>a;a++)mod_ctio.wuint8(e[a],t,r,i+a);for(;n>a;a++)mod_ctio.wuint8(0,t,i+a);return n}function ctGetBasicTypes(){var n,e={};for(n in deftypes)e[n]=deftypes[n];return e}function ctParseType(e){var n,t,r,i;if("string"!=typeof e)throw new Error("type must be a Javascript string");if(t=e.lastIndexOf("]"),-1==t){if(-1!=e.lastIndexOf("["))throw new Error("found invalid type with '[' but no corresponding ']'");return{type:e}}if(n=e.lastIndexOf("["),-1==n)throw new Error("found invalid type with ']' but no corresponding '['");if(n>=t)throw new Error("malformed type, ']' appears before '['");return r=e.substring(0,n),i=e.substring(n+1,t),{type:r,len:i}}function ctCheckReq(e,n,t){var r,i,a,o,s,u={};if(!(e instanceof Array))throw new Error("definition is not an array");if(0===e.length)throw new Error("definition must have at least one element");for(r=0;r<e.length;r++){if(a=e[r],!(a instanceof Object))throw new Error("definition must be an array ofobjects");if(o=Object.keys(a),1!=o.length)throw new Error("definition entry must only have one key");if(o[0]in u)throw new Error("Specified name already specified: "+o[0]);if(!("type"in a[o[0]]))throw new Error("missing required type definition");for(s=ctParseType(a[o[0]].type);void 0!==s.len;){if(isNaN(parseInt(s.len,10))&&!(s.len in u))throw new Error("Given an array length without a matching type");s=ctParseType(s.type)}if(!(s.type in n))throw new Error("type not found or typdefed: "+s.type);if(void 0!==t)for(i=0;i<t.length;i++)if(!(t[i]in a[o[0]]))throw new Error("Missing required field: "+t[i]);u[o[0]]=!0}}function CTypeParser(e){if(!e)throw new Error("missing required argument");if(!("endian"in e))throw new Error("missing required endian value");if("big"!=e.endian&&"little"!=e.endian)throw new Error("Invalid endian type");if("char-type"in e&&"uint8"!=e["char-type"]&&"int8"!=e["char-type"])throw new Error("invalid option for char-type: "+e["char-type"]);this.endian=e.endian,this.types=ctGetBasicTypes(),"char-type"in e&&"uint8"==e["char-type"]&&(this.types["char"]=this.types.uint8_t),"char-type"in e&&"int8"==e["char-type"]&&(this.types["char"]=this.types.int8_t)}function ctResolveArray(e,n){for(var t="",r=ctParseType(e);void 0!==r.len;){if(isNaN(parseInt(r.len,10))){if("number"!=typeof n[r.len])throw new Error("cannot sawp in non-number for array value");t="["+n[r.len]+"]"+t}else t="["+r.len+"]"+t;r=ctParseType(r.type)}return t=r.type+t}function getValues(e){var n,t,r;for(t=[],n=0;n<e.length;n++)r=Object.keys(e[n])[0],mod_assert.ok("value"in e[n][r]),t.push(e[n][r].value);return t}function toAbs64(e){if(void 0===e)throw new Error("missing required arg: value");if(!Array.isArray(e))throw new Error("value must be an array");if(2!=e.length)throw new Error("value must be an array of length 2");if(e[0]>=1048576)throw new Error("value would become approximated");return e[0]*Math.pow(2,32)+e[1]}function toApprox64(e){if(void 0===e)throw new Error("missing required arg: value");if(!Array.isArray(e))throw new Error("value must be an array");if(2!=e.length)throw new Error("value must be an array of length 2");return Math.pow(2,32)*e[0]+e[1]}function parseCTF(e,n){var t=new CTypeParser(n);return mod_ctf.ctfParseJson(e,t),t}var mod_ctf=require("./ctf.js"),mod_ctio=require("./ctio.js"),mod_assert=require("assert"),deftypes={uint8_t:{read:ctReadUint8,write:ctWriteUint8},uint16_t:{read:ctReadUint16,write:ctWriteUint16},uint32_t:{read:ctReadUint32,write:ctWriteUint32},uint64_t:{read:ctReadUint64,write:ctWriteUint64},int8_t:{read:ctReadSint8,write:ctWriteSint8},int16_t:{read:ctReadSint16,write:ctWriteSint16},int32_t:{read:ctReadSint32,write:ctWriteSint32},int64_t:{read:ctReadSint64,write:ctWriteSint64},"float":{read:ctReadFloat,write:ctWriteFloat},"double":{read:ctReadDouble,write:ctWriteDouble},"char":{read:ctReadChar,write:ctWriteChar},"char[]":{read:ctReadCharArray,write:ctWriteCharArray}};CTypeParser.prototype.setEndian=function(e){if("big"!=e&&"little"!=e)throw new Error("invalid endian type, must be big or little");this.endian=e},CTypeParser.prototype.getEndian=function(){return this.endian},CTypeParser.prototype.typedef=function(e,n){var t;if(void 0===e)throw new(Error("missing required typedef argument: name"));if(void 0===n)throw new(Error("missing required typedef argument: value"));if("string"!=typeof e)throw new(Error("the name of a type must be a string"));if(t=ctParseType(e),void 0!==t.len)throw new Error("Cannot have an array in the typedef name");if(e in this.types)throw new Error("typedef name already present: "+e);if("string"!=typeof n&&!(n instanceof Array))throw new Error("typedef value must either be a string or struct");if("string"==typeof n){if(t=ctParseType(n),void 0!==t.len&&isNaN(parseInt(t.len,10)))throw new(Error("typedef value must use fixed size array when outside of a struct"));this.types[e]=n}else ctCheckReq(n,this.types),this.types[e]=n},CTypeParser.prototype.lstypes=function(){var e,n={};for(e in this.types)e in deftypes||(n[e]=this.types[e]);return n},CTypeParser.prototype.resolveTypedef=function(e,n,t,r,i){var a;if(mod_assert.ok(e in this.types),"string"==typeof this.types[e]){if(a=ctParseType(this.types[e]),"read"==n)return this.readEntry(a,t,r);if("write"==n)return this.writeEntry(i,a,t,r);throw new Error("invalid dispatch type to resolveTypedef")}if("read"==n)return this.readStruct(this.types[e],t,r);if("write"==n)return this.writeStruct(i,this.types[e],t,r);throw new Error("invalid dispatch type to resolveTypedef")},CTypeParser.prototype.readEntry=function(e,n,t){var r,i;if(void 0!==e.len){if(i=parseInt(e.len,10),isNaN(i))throw new Error("somehow got a non-numeric length");r="char"==e.type?this.types["char[]"].read(i,this.endian,n,t):this.readArray(e.type,i,n,t)}else r=e.type in deftypes?this.types[e.type].read(this.endian,n,t):this.resolveTypedef(e.type,"read",n,t);return r},CTypeParser.prototype.readArray=function(e,n,t,r){var i,a,o,s=r,u=new Array(n);for(o=ctParseType(e),i=0;n>i;i++)a=this.readEntry(o,t,r),r+=a.size,u[i]=a.value;return{value:u,size:r-s}},CTypeParser.prototype.readStruct=function(e,n,t){var r,i,a,o,s,u=t,l={};for(i=0;i<e.length;i++)s=Object.keys(e[i])[0],o=e[i][s],a=ctParseType(ctResolveArray(o.type,l)),"offset"in o&&(t=u+o.offset),r=this.readEntry(a,n,t),t+=r.size,l[s]=r.value;return{value:l,size:t-u}},CTypeParser.prototype.readData=function(e,n,t){if(void 0===e)throw new Error("missing definition for what we should beparsing");if(void 0===n)throw new Error("missing buffer for what we should be parsing");if(void 0===t)throw new Error("missing offset for what we should be parsing");return ctCheckReq(e,this.types),this.readStruct(e,n,t).value},CTypeParser.prototype.writeArray=function(e,n,t,r,i){var a,o,s=i;if(!(e instanceof Array))throw new Error("asked to write an array, but value is not an array");if(e.length!=t)throw new Error("asked to write array of length "+t+" but that does not match value length: "+e.length);for(o=ctParseType(n),a=0;t>a;a++)i+=this.writeEntry(e[a],o,r,i);return i-s},CTypeParser.prototype.writeEntry=function(e,n,t,r){var i,a;if(void 0!==n.len){if(i=parseInt(n.len,10),isNaN(i))throw new Error("somehow got a non-numeric length");a="char"==n.type?this.types["char[]"].write(e,i,this.endian,t,r):this.writeArray(e,n.type,i,t,r)}else a=n.type in deftypes?this.types[n.type].write(e,this.endian,t,r):this.resolveTypedef(n.type,"write",t,r,e);return a},CTypeParser.prototype.writeStruct=function(e,n,t,r){var i,a,o,s,u=r,l={};for(i=0;i<n.length;i++)s=Object.keys(n[i])[0],a=n[i][s],o=ctParseType(ctResolveArray(a.type,l)),"offset"in a&&(r=u+a.offset),r+=this.writeEntry(e[i],o,t,r),l[s]=e[i];return r},CTypeParser.prototype.writeData=function(e,n,t,r){var i;if(void 0===e)throw new Error("missing definition for what we should beparsing");if(void 0===n)throw new Error("missing buffer for what we should be parsing");if(void 0===t)throw new Error("missing offset for what we should be parsing");if(i=null!=r&&void 0!=r){if(!Array.isArray(r))throw new Error("missing values for writing");ctCheckReq(e,this.types)}else ctCheckReq(e,this.types,["value"]);this.writeStruct(i?r:getValues(e),e,n,t)},exports.Parser=CTypeParser,exports.toAbs64=toAbs64,exports.toApprox64=toApprox64,exports.parseCTF=parseCTF,exports.ruint8=mod_ctio.ruint8,exports.ruint16=mod_ctio.ruint16,exports.ruint32=mod_ctio.ruint32,exports.ruint64=mod_ctio.ruint64,exports.wuint8=mod_ctio.wuint8,exports.wuint16=mod_ctio.wuint16,exports.wuint32=mod_ctio.wuint32,exports.wuint64=mod_ctio.wuint64,exports.rsint8=mod_ctio.rsint8,exports.rsint16=mod_ctio.rsint16,exports.rsint32=mod_ctio.rsint32,exports.rsint64=mod_ctio.rsint64,exports.wsint8=mod_ctio.wsint8,exports.wsint16=mod_ctio.wsint16,exports.wsint32=mod_ctio.wsint32,exports.wsint64=mod_ctio.wsint64,exports.rfloat=mod_ctio.rfloat,exports.rdouble=mod_ctio.rdouble,exports.wfloat=mod_ctio.wfloat,exports.wdouble=mod_ctio.wdouble;