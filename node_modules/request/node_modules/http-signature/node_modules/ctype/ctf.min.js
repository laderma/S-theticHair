function ctfParseInteger(e,n){var t,r,i,a;if(t=e.name,!("signed"in e.integer))throw new Error("Malformed CTF JSON: integer missing signed value");if(!("length"in e.integer))throw new Error("Malformed CTF JSON: integer missing length value");if(r=e.integer.signed,i=e.integer.length,a=null,r&&1==i?a="int8_t":1==i?a="uint8_t":r&&2==i?a="int16_t":2==i?a="uint16_t":r&&4==i?a="int32_t":4==i?a="uint32_t":r&&8==i?a="int64_t":8==i&&(a="uint64_t"),null===a)throw new Error("Malformed CTF JSON: integer has unsupported length and sign - "+i+"/"+r);return t!=a?"char"==t?void ASSERT("int8_t"==a):void n.typedef(t,a):void 0}function ctfParseFloat(e,n){var t,r;if(t=e.name,!("length"in e["float"]))throw new Error("Malformed CTF JSON: float missing length value");if(r=e["float"].length,4!=r&&8!=r)throw new Error("Malformed CTF JSON: float has invalid length value");if(4==r){if("float"==t)return;n.typedef(t,"float")}else if(8==r){if("double"==t)return;n.typedef(t,"double")}}function ctfParseTypedef(e,n){var t,r,i;if(t=e.name,"string"!=typeof e.typedef)throw new Error("Malformed CTF JSON: typedef value in not a string");for(r=e.typedef,i=0;i<ctf_deftypes.length;i++)if(t==ctf_deftypes[i])return;n.typedef(t,r)}function ctfParseStruct(e,n){var t,r,i,a,o,s,u;if(s=[],!Array.isArray(e.struct))throw new Error("Malformed CTF JSON: struct value is not an array");for(i=0;i<e.struct.length;i++){if(a=e.struct[i],!("name"in a))throw new Error("Malformed CTF JSON: struct member missing name");if(!("type"in a))throw new Error("Malformed CTF JSON: struct member missing type");if("string"!=typeof a.name)throw new Error("Malformed CTF JSON: struct member name isn't a string");if("string"!=typeof a.type)throw new Error("Malformed CTF JSON: struct member type isn't a string");t=a.name,r=a.type,o=r.indexOf(" ["),-1!=o&&(r=r.substring(0,o)+r.substring(o+1,r.length)),u={},u[t]={type:r},s.push(u)}t=e.name,n.typedef(t,s)}function ctfParseEntry(e,n){var t,r;if(!("name"in e))throw new Error('Malformed CTF JSON: entry missing "name" section');for(t=0;t<ctf_entries.length;t++)ctf_entries[t]in e&&r++;if(0===r)throw new Error("Malformed CTF JSON: found no entries");if(r>=2)throw new Error("Malformed CTF JSON: found more than one entry");return"integer"in e?void ctfParseInteger(e,n):"float"in e?void ctfParseFloat(e,n):"typedef"in e?void ctfParseTypedef(e,n):"struct"in e?void ctfParseStruct(e,n):void ASSERT(!1,"shouldn't reach here")}function ctfParseJson(e,n){var t,r;if(ASSERT(e),ASSERT(n),!("metadata"in e))throw new Error("Invalid CTF JSON: missing metadata section");if(!("ctf2json_version"in e.metadata))throw new Error("Invalid CTF JSON: missing ctf2json_version");for(t=e.metadata.ctf2json_version,r=0;r<ctf_versions.length&&ctf_versions[r]!=t;r++);if(r==ctf_versions.length)throw new Error("Unsuported ctf2json_version: "+t);if(!("data"in e))throw new Error("Invalid CTF JSON: missing data section");if(!Array.isArray(e.data))throw new Error("Malformed CTF JSON: data section is not an array");for(r=0;r<e.data.length;r++)ctfParseEntry(e.data[r],n)}var mod_assert=require("assert"),ASSERT=mod_assert.ok,ctf_versions=["1.0"],ctf_entries=["integer","float","typedef","struct"],ctf_deftypes=["int8_t","uint8_t","int16_t","uint16_t","int32_t","uint32_t","float","double"];exports.ctfParseJson=ctfParseJson;